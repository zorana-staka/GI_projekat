import gzip
import re
import toolz

from Body_header_line import Body_header_line
from Body_record import Body_record
from Input_file import Input_file


class Output_file:
    """ Represents output file that will be generated by combining and merging all input files. """

    def __init__(self, arguments):
        self.path = ""
        self.file = None
        self.compressed = None
        self.version = None
        self.body_header_line = None
        self.list_of_header_objects = list()
        self.list_of_header_objects_without_ID = list()
        self.list_of_body_objects = list()
        self.list_of_contigs = list()
        self.list_of_input_files_paths = list()
        self.list_of_input_files = list()
        self.list_of_samples_to_be_combined = list()
        self.arguments = arguments
        self.extract_info_from_arguments()
        self.error_message = ""
        self.convert = lambda text: int(text) if text.isdigit() else text
        self.alphanum_key = lambda key: [self.convert(c) for c in re.split('([0-9]+)', key)]

    def extract_info_from_arguments(self):
        """ Sets the attributes from respective user input parameters. """

        for sample_name in self.arguments['--sample_name']:
            self.list_of_samples_to_be_combined.append(sample_name)

        for file_path in self.arguments['--input_file']:
            file_object = Input_file(file_path, self.list_of_samples_to_be_combined)
            self.list_of_input_files.append(file_object)
            self.list_of_input_files_paths.append(file_path)

        if self.arguments['--out']:

            if self.arguments['--output_format'] == 'COMPRESSED':
                self.file = gzip.open(self.arguments['--out'] + '.gz', "w+b")
                self.compressed = True
            elif self.arguments['--output_format'] == 'UNCOMPRESSED':
                self.file = open(self.arguments['--out'], "w+")
                self.compressed = False
            else:
                if self.list_of_input_files[0].compressed:
                    self.file = gzip.open(self.arguments['--out'] + '.gz', "w+b")
                    self.compressed = True
                else:
                    self.file = open(self.arguments['--out'], "w+")

    def read_input_files(self):
        """ This method reads all of the input files by calling method open_and_read_file of Input_file class.
            After reading each file objects for header and body parts are added to the convenient list of objects.
            Contig tags has a separate list, because the sorting rules do not apply for them.
            Filter methods are used to delete duplicates.
            Arrange methods are used to sort header and body part.
            Verify methods are used to check if rules for VCF files are respected.
        """

        for input_file in self.list_of_input_files:
            input_file.open_and_read_file()
            if input_file.invalid is True:
                return False
            self.list_of_header_objects.extend(input_file.list_of_header_objects)
            self.list_of_header_objects_without_ID.extend(input_file.list_of_header_objects_without_ID)
            self.list_of_contigs.extend(input_file.list_of_contigs)

            self.list_of_body_objects.extend(input_file.list_of_body_objects)

        if not self.check_samples_in_all_input_files():
            return False

        self.adjust_body_records_to_samples()
        self.create_body_header_line_for_output()

        # self.filter_header_objects()
        self.list_of_header_objects = list(toolz.unique(self.list_of_header_objects, key=lambda x: x.tag_and_ID))
        self.list_of_header_objects_without_ID = list(
            toolz.unique(self.list_of_header_objects_without_ID, key=lambda x: x.line))
        self.list_of_contigs = list(toolz.unique(self.list_of_contigs, key=lambda x: x.line))
        # self.filter_body_objects()
        self.list_of_body_objects = list(toolz.unique(self.list_of_body_objects, key=lambda x: x.line))

        # adjust
        self.list_of_header_objects.extend(self.list_of_header_objects_without_ID)
        self.list_of_header_objects.sort(key=lambda x: x.line)
        self.list_of_header_objects.extend(self.list_of_contigs)
        self.list_of_header_objects.sort(key=lambda x: x.tag, reverse=False)
        self.list_of_body_objects.sort(key=lambda x: self.alphanum_key(x.line))

        return self.verify_and_merge_body_records()

    def write_output_file(self):
        """ Writes output file by calling different methods, regarding if the output file is uncompressed or not. """
        if self.compressed:
            self.write_header_in_gz_file()
            self.write_body_in_gz_file()
        else:
            self.write_header()
            self.write_body()

    def write_header(self):
        """ Writes header in uncompressed file, or on the stdout, regarding input arguments. """
        if self.arguments['--out']:
            for list_item in self.list_of_header_objects:
                self.file.write(list_item.line)
            self.file.write(self.body_header_line.line)
        else:
            for list_item in self.list_of_header_objects:
                print(list_item.line)
            print(self.body_header_line.line)

    def write_body(self):
        """ Writes body in uncompressed file, or on the stdout, regarding input arguments. """
        if self.arguments['--out']:
            for list_item in self.list_of_body_objects:
                self.file.write(list_item.line)
        else:
            for list_item in self.list_of_body_objects:
                print(list_item.line)

        self.file.close()

    def write_header_in_gz_file(self):
        """ Writes header in compressed file, or on the stdout, regarding input arguments. """
        if self.arguments['--out']:
            for list_item in self.list_of_header_objects:
                self.file.write(list_item.line.encode('utf-8'))
            self.file.write(self.body_header_line.line)
        else:
            for list_item in self.list_of_header_objects:
                print(list_item.line.encode('utf-8'))

    def write_body_in_gz_file(self):
        """ Writes body in compressed file, or on the stdout, regarding input arguments. """
        if self.arguments['--out']:
            for list_item in self.list_of_body_objects:
                self.file.write(list_item.line.encode('utf-8'))
        else:
            for list_item in self.list_of_body_objects:
                print(list_item.line.encode('utf-8'))

        self.file.close()

    def adjust_body_records_to_samples(self):
        """ First make a list of samples that need to be combined if the list_of_samples_to_be_combined is empty. """
        if len(self.list_of_samples_to_be_combined) == 0:
            self.determinate_samples_to_be_combined()
        Body_header_line.list_of_samples_to_be_combined = self.list_of_samples_to_be_combined
        Body_record.list_of_samples_to_be_combined = self.list_of_samples_to_be_combined
        for body_object in self.list_of_body_objects:
            body_object.update_line()

    def create_body_header_line_for_output(self):
        self.body_header_line = Body_header_line("")
        self.body_header_line.has_format_field = len(Body_header_line.list_of_samples_to_be_combined) > 0
        self.body_header_line.samples_names = Body_header_line.list_of_samples_to_be_combined
        self.body_header_line.update_line()

    def check_samples_in_all_input_files(self):
        for input_file in self.list_of_input_files:
            if not set(self.list_of_samples_to_be_combined).issubset(set(input_file.body_header_line.samples_names)):
                return False

        return True

    def determinate_samples_to_be_combined(self):
        for input_file in self.list_of_input_files:
            for sample_name in input_file.body_header_line.samples_names:
                if sample_name not in self.list_of_samples_to_be_combined:
                    self.list_of_samples_to_be_combined.append(sample_name)
        self.list_of_samples_to_be_combined = list(set(self.list_of_samples_to_be_combined))

    def verify_and_merge_body_records(self):
        index = 0
        while index + 1 < len(self.list_of_body_objects):
            if (self.check_condition_for_merging_records(self.list_of_body_objects[index],
                                                         self.list_of_body_objects[index + 1])):

                if self.list_of_body_objects[index].ref == self.list_of_body_objects[index + 1].ref:

                    if self.list_of_body_objects[index].filter == self.list_of_body_objects[index + 1].filter \
                            or (self.list_of_body_objects[index].filter == "PASS" or self.list_of_body_objects[
                        index + 1].filter == "PASS"):
                        self.list_of_body_objects[index].id = self.determinate_id(
                            self.list_of_body_objects[index].id, self.list_of_body_objects[index + 1].id)

                        self.list_of_body_objects[index].alt = self.determinate_alt(
                            self.list_of_body_objects[index].alt, self.list_of_body_objects[index + 1].alt)

                        self.list_of_body_objects[index].qual = self.determinate_qual(
                            self.list_of_body_objects[index].qual, self.list_of_body_objects[index + 1].qual)

                        self.determinate_info(self.list_of_body_objects[index],
                                              self.list_of_body_objects[index + 1])

                        self.list_of_body_objects[index].update_line()

                        del self.list_of_body_objects[index + 1]

                    else:
                        return False

                elif self.list_of_body_objects[index].ref != self.list_of_body_objects[index + 1].ref and \
                        len(str(self.list_of_body_objects[index].ref)) == \
                        len(str(self.list_of_body_objects[index + 1].ref)):
                    return False

            index += 1

        return True

    def check_condition_for_merging_records(self, record_one, record_two):
        if record_one.pos == record_two.pos and record_one.chrom == record_two.chrom:
            if record_one.has_format_field and record_two.has_format_field:
                if record_one.format != record_two.format:
                    return False
                else:
                    samples_data_record_one = (record_one.line.split('\t'))[8:]
                    samples_data_record_two = (record_two.line.split('\t'))[8:]

                    if len(samples_data_record_one) == len(samples_data_record_two):
                        index = 1
                        while index < len(samples_data_record_one):
                            if samples_data_record_one[index] != samples_data_record_two[index]:
                                return False
                            index += 1
            else:
                return True
        else:
            return False

    def determinate_id_alt_qual_info(self, record_one, record_two):
        pass

    def determinate_info(self, record_one, record_two):
        info_data = {}
        for key, value in record_one.data_from_info.items():
            if key in record_two.data_from_info:
                if value == record_two.data_from_info[key]:
                    info_data[key] = value
            else:
                info_data[key] = value

        for key, value in record_two.data_from_info.items():
            if key not in record_one.data_from_info:
                info_data[key] = value

        record_one.update_data_from_info(info_data)

    def determinate_id(self, id_one, id_two):
        if id_one == id_two:
            return id_one
        if id_one == ".":
            return id_two
        if id_two == ".":
            return id_one
        return id_one + "," + id_two

    def determinate_qual(self, qual_one, qual_two):
        if qual_one == qual_two:
            return qual_one
        if qual_one == ".":
            return qual_two
        if qual_two == ".":
            return qual_one
        if float(qual_one) < float(qual_two):
            return qual_one
        return qual_one

    # obraditi i za * i za N
    def determinate_alt(self, alt_one, alt_two):
        if alt_one == alt_two:
            return alt_one
        if alt_one == ".":
            return alt_two
        if alt_two == ".":
            return alt_one
        return alt_one + "," + alt_two
